/* Generated by wayland-scanner 1.21.0 */

#ifndef NEXT_CONTROL_V1_CLIENT_PROTOCOL_H
#define NEXT_CONTROL_V1_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_next_control_v1 The next_control_v1 protocol
 * @section page_ifaces_next_control_v1 Interfaces
 * - @subpage page_iface_next_control_v1 - Run compositor commands
 * - @subpage page_iface_next_command_callback_v1 - callback object
 * @section page_copyright_next_control_v1 Copyright
 * <pre>
 *
 * Copyright 2022 Aakash Sen Sharma
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * </pre>
 */
struct next_command_callback_v1;
struct next_control_v1;
struct wl_seat;

#ifndef NEXT_CONTROL_V1_INTERFACE
#define NEXT_CONTROL_V1_INTERFACE
/**
 * @page page_iface_next_control_v1 next_control_v1
 * @section page_iface_next_control_v1_desc Description
 *
 * This interface allows clients to run compositor commands and receive a
 * success/failure response with output or a failure message respectively.
 * @section page_iface_next_control_v1_api API
 * See @ref iface_next_control_v1.
 */
/**
 * @defgroup iface_next_control_v1 The next_control_v1 interface
 *
 * This interface allows clients to run compositor commands and receive a
 * success/failure response with output or a failure message respectively.
 */
extern const struct wl_interface next_control_v1_interface;
#endif
#ifndef NEXT_COMMAND_CALLBACK_V1_INTERFACE
#define NEXT_COMMAND_CALLBACK_V1_INTERFACE
/**
 * @page page_iface_next_command_callback_v1 next_command_callback_v1
 * @section page_iface_next_command_callback_v1_desc Description
 *
 * This object is created by the run_command request. Exactly one of the
 * success or failure events will be sent. This object will be destroyed
 * by the compositor after one of the events is sent.
 * @section page_iface_next_command_callback_v1_api API
 * See @ref iface_next_command_callback_v1.
 */
/**
 * @defgroup iface_next_command_callback_v1 The next_command_callback_v1 interface
 *
 * This object is created by the run_command request. Exactly one of the
 * success or failure events will be sent. This object will be destroyed
 * by the compositor after one of the events is sent.
 */
extern const struct wl_interface next_command_callback_v1_interface;
#endif

#define NEXT_CONTROL_V1_DESTROY 0
#define NEXT_CONTROL_V1_ADD_ARGUMENT 1
#define NEXT_CONTROL_V1_RUN_COMMAND 2


/**
 * @ingroup iface_next_control_v1
 */
#define NEXT_CONTROL_V1_DESTROY_SINCE_VERSION 1
/**
 * @ingroup iface_next_control_v1
 */
#define NEXT_CONTROL_V1_ADD_ARGUMENT_SINCE_VERSION 1
/**
 * @ingroup iface_next_control_v1
 */
#define NEXT_CONTROL_V1_RUN_COMMAND_SINCE_VERSION 1

/** @ingroup iface_next_control_v1 */
static inline void
next_control_v1_set_user_data(struct next_control_v1 *next_control_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) next_control_v1, user_data);
}

/** @ingroup iface_next_control_v1 */
static inline void *
next_control_v1_get_user_data(struct next_control_v1 *next_control_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) next_control_v1);
}

static inline uint32_t
next_control_v1_get_version(struct next_control_v1 *next_control_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) next_control_v1);
}

/**
 * @ingroup iface_next_control_v1
 *
 * This request indicates that the client will not use the
 * next_control object any more. Objects that have been created
 * through this instance are not affected.
 */
static inline void
next_control_v1_destroy(struct next_control_v1 *next_control_v1)
{
	wl_proxy_marshal_flags((struct wl_proxy *) next_control_v1,
			 NEXT_CONTROL_V1_DESTROY, NULL, wl_proxy_get_version((struct wl_proxy *) next_control_v1), WL_MARSHAL_FLAG_DESTROY);
}

/**
 * @ingroup iface_next_control_v1
 *
 * Arguments are stored by the server in the order they were sent until
 * the run_command request is made.
 */
static inline void
next_control_v1_add_argument(struct next_control_v1 *next_control_v1, const char *argument)
{
	wl_proxy_marshal_flags((struct wl_proxy *) next_control_v1,
			 NEXT_CONTROL_V1_ADD_ARGUMENT, NULL, wl_proxy_get_version((struct wl_proxy *) next_control_v1), 0, argument);
}

/**
 * @ingroup iface_next_control_v1
 *
 * Execute the command built up using the add_argument request for the
 * given seat.
 */
static inline struct next_command_callback_v1 *
next_control_v1_run_command(struct next_control_v1 *next_control_v1, struct wl_seat *seat)
{
	struct wl_proxy *callback;

	callback = wl_proxy_marshal_flags((struct wl_proxy *) next_control_v1,
			 NEXT_CONTROL_V1_RUN_COMMAND, &next_command_callback_v1_interface, wl_proxy_get_version((struct wl_proxy *) next_control_v1), 0, seat, NULL);

	return (struct next_command_callback_v1 *) callback;
}

/**
 * @ingroup iface_next_command_callback_v1
 * @struct next_command_callback_v1_listener
 */
struct next_command_callback_v1_listener {
	/**
	 * Command successful
	 *
	 * Sent when the command has been successfully received and
	 * executed by the compositor. Some commands may produce output, in
	 * which case the output argument will be a non-empty string.
	 * @param output the output of the command
	 */
	void (*success)(void *data,
			struct next_command_callback_v1 *next_command_callback_v1,
			const char *output);
	/**
	 * Command failed
	 *
	 * Sent when the command could not be carried out. This could be
	 * due to sending a non-existent command, no command, not enough
	 * arguments, too many arguments, invalid arguments, etc.
	 * @param failure_message a message explaining why failure occurred
	 */
	void (*failure)(void *data,
			struct next_command_callback_v1 *next_command_callback_v1,
			const char *failure_message);
};

/**
 * @ingroup iface_next_command_callback_v1
 */
static inline int
next_command_callback_v1_add_listener(struct next_command_callback_v1 *next_command_callback_v1,
				      const struct next_command_callback_v1_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) next_command_callback_v1,
				     (void (**)(void)) listener, data);
}

/**
 * @ingroup iface_next_command_callback_v1
 */
#define NEXT_COMMAND_CALLBACK_V1_SUCCESS_SINCE_VERSION 1
/**
 * @ingroup iface_next_command_callback_v1
 */
#define NEXT_COMMAND_CALLBACK_V1_FAILURE_SINCE_VERSION 1


/** @ingroup iface_next_command_callback_v1 */
static inline void
next_command_callback_v1_set_user_data(struct next_command_callback_v1 *next_command_callback_v1, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) next_command_callback_v1, user_data);
}

/** @ingroup iface_next_command_callback_v1 */
static inline void *
next_command_callback_v1_get_user_data(struct next_command_callback_v1 *next_command_callback_v1)
{
	return wl_proxy_get_user_data((struct wl_proxy *) next_command_callback_v1);
}

static inline uint32_t
next_command_callback_v1_get_version(struct next_command_callback_v1 *next_command_callback_v1)
{
	return wl_proxy_get_version((struct wl_proxy *) next_command_callback_v1);
}

/** @ingroup iface_next_command_callback_v1 */
static inline void
next_command_callback_v1_destroy(struct next_command_callback_v1 *next_command_callback_v1)
{
	wl_proxy_destroy((struct wl_proxy *) next_command_callback_v1);
}

#ifdef  __cplusplus
}
#endif

#endif
